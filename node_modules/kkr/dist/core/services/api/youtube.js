"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VideoPlayabilityStatusError = exports.ParseError = void 0;
const axios_1 = require("axios");
const ErrorMessages = require("../../messages/error");
class ParseError extends Error {
}
exports.ParseError = ParseError;
class VideoPlayabilityStatusError extends Error {
}
exports.VideoPlayabilityStatusError = VideoPlayabilityStatusError;
class YouTubeService {
    static getVideoIdByUrl(videoUrl) {
        let videoId;
        if (!videoUrl) {
            throw new ParseError(ErrorMessages.CANT_PARSE_VIDEO_URL);
        }
        if (videoUrl.includes("youtube.com")) {
            videoId = videoUrl.match(/v=(.+?)(&|$)/im)[1];
        }
        else if (videoUrl.includes("youtu.be")) {
            videoId = videoUrl.match(/youtu.be\/(.+?)(&|$)/im)[1];
        }
        else {
            throw new ParseError(ErrorMessages.CANT_PARSE_VIDEO_URL);
        }
        return videoId;
    }
    /**
     * 解析视频信息
     * @param videoUrl
     */
    static getVideoInfo(videoUrl) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
        return __awaiter(this, void 0, void 0, function* () {
            const videoId = YouTubeService.getVideoIdByUrl(videoUrl);
            const API_URL = `https://youtube.com/watch?v=${videoId}`;
            const videoInfoResponse = yield axios_1.default.get(API_URL, {
                headers: {
                    Referer: "https://www.youtube.com/",
                    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36",
                },
            });
            let playerResponse;
            if (videoInfoResponse.data.match(/ytplayer\.config = ({.+?});/)) {
                const playerConfig = JSON.parse(videoInfoResponse.data.match(/ytplayer\.config = ({.+?});/)[1]);
                playerResponse = JSON.parse(playerConfig.args.player_response);
            }
            else if (videoInfoResponse.data.match(/ytInitialPlayerResponse = ({.+?});/)) {
                playerResponse = JSON.parse(videoInfoResponse.data.match(/ytInitialPlayerResponse = ({.+?});/)[1]);
            }
            else {
                throw new ParseError("解析视频信息失败");
            }
            const title = (_a = playerResponse === null || playerResponse === void 0 ? void 0 : playerResponse.videoDetails) === null || _a === void 0 ? void 0 : _a.title;
            if (!playerResponse.streamingData) {
                const errorReason = ((_e = (_d = (_c = (_b = playerResponse === null || playerResponse === void 0 ? void 0 : playerResponse.playabilityStatus) === null || _b === void 0 ? void 0 : _b.errorScreen) === null || _c === void 0 ? void 0 : _c.playerErrorMessageRenderer) === null || _d === void 0 ? void 0 : _d.subreason) === null || _e === void 0 ? void 0 : _e.simpleText) || ((_l = (_k = (_j = (_h = (_g = (_f = playerResponse === null || playerResponse === void 0 ? void 0 : playerResponse.playabilityStatus) === null || _f === void 0 ? void 0 : _f.errorScreen) === null || _g === void 0 ? void 0 : _g.playerErrorMessageRenderer) === null || _h === void 0 ? void 0 : _h.subreason) === null || _j === void 0 ? void 0 : _j.runs) === null || _k === void 0 ? void 0 : _k[0]) === null || _l === void 0 ? void 0 : _l.text);
                if (errorReason) {
                    throw new VideoPlayabilityStatusError(errorReason);
                }
                throw new ParseError(ErrorMessages.NOT_A_LIVE_STREAM);
            }
            const mpdUrl = playerResponse.streamingData.dashManifestUrl;
            const isLowLatencyLiveStream = !!((_m = playerResponse === null || playerResponse === void 0 ? void 0 : playerResponse.videoDetails) === null || _m === void 0 ? void 0 : _m.isLowLatencyLiveStream);
            const latencyClass = (_o = playerResponse === null || playerResponse === void 0 ? void 0 : playerResponse.videoDetails) === null || _o === void 0 ? void 0 : _o.latencyClass;
            const isLiveDvrEnabled = !!((_p = playerResponse === null || playerResponse === void 0 ? void 0 : playerResponse.videoDetails) === null || _p === void 0 ? void 0 : _p.isLiveDvrEnabled);
            const isPremiumVideo = !!((_q = playerResponse === null || playerResponse === void 0 ? void 0 : playerResponse.videoDetails) === null || _q === void 0 ? void 0 : _q.isLive) && !((_r = playerResponse === null || playerResponse === void 0 ? void 0 : playerResponse.videoDetails) === null || _r === void 0 ? void 0 : _r.isLiveContent);
            return {
                title,
                mpdUrl,
                isLowLatencyLiveStream,
                latencyClass,
                isLiveDvrEnabled,
                isPremiumVideo,
            };
        });
    }
    static getHeartbeat(videoUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            const videoId = YouTubeService.getVideoIdByUrl(videoUrl);
            const API_URL = `https://www.youtube.com/youtubei/v1/player/heartbeat?alt=json&key=AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8`;
            const videoInfoResponse = yield axios_1.default.post(API_URL, {
                videoId: videoId,
                context: {
                    client: {
                        clientName: "WEB",
                        clientVersion: "2.20200618.01.01",
                    },
                },
                heartbeatRequestParams: {
                    heartbeatChecks: ["HEARTBEAT_CHECK_TYPE_LIVE_STREAM_STATUS"],
                },
            });
            return videoInfoResponse.data.playabilityStatus;
        });
    }
}
exports.default = YouTubeService;
//# sourceMappingURL=youtube.js.map