"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DownloadError = void 0;
const fs = require("fs");
const path = require("path");
const events_1 = require("events");
const axios_1 = require("axios");
const youtube_1 = require("./services/api/youtube");
const mpd_parser_1 = require("./mpd_parser");
const download_files_1 = require("../utils/download_files");
const video_muxer_1 = require("../utils/video_muxer");
const merge_files_1 = require("../utils/merge_files");
const delete_directory_1 = require("../utils/delete_directory");
const select_format_1 = require("../utils/select_format");
const escape_filename_1 = require("../utils/escape_filename");
const system_1 = require("../utils/system");
const analyse_concat_method_1 = require("../utils/analyse_concat_method");
const logger_1 = require("./services/logger");
class DownloadError extends Error {
}
exports.DownloadError = DownloadError;
class Downloader extends events_1.EventEmitter {
    constructor(videoUrl, { format, verbose, keep, threads, concatMethod, headers }) {
        super();
        this.verbose = false;
        this.maxThreads = 10;
        this.enableCustomHeaders = false;
        this.videoUrl = videoUrl;
        if (format) {
            this.format = format;
        }
        this.logger = logger_1.default;
        if (verbose) {
            this.logger.enableDebug();
        }
        if (keep) {
            this.keepTemporaryFiles = true;
        }
        if (threads) {
            this.maxThreads = threads;
        }
        if (concatMethod) {
            this.concatMethod = +concatMethod;
        }
        if (headers) {
            this.enableCustomHeaders = true;
            this.rawHeaders = headers;
        }
    }
    download() {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`使用至多 ${this.maxThreads} 线程下载`);
            this.isFFmpegAvailable = yield system_1.isFFmpegAvailable();
            this.isFFprobeAvailable = yield system_1.isFFprobeAvailable();
            if (!this.isFFmpegAvailable) {
                this.logger.warning("FFmpeg不可用 视频不会自动合并");
            }
            if (!this.isFFprobeAvailable) {
                this.logger.warning("FFprobe不可用 无法准确确定合并方式 临时文件将会被保留");
                this.keepTemporaryFiles = true;
            }
            // 解析视频信息
            this.logger.info("正在获取视频信息");
            const { title, mpdUrl, isLowLatencyLiveStream, isPremiumVideo } = yield youtube_1.default.getVideoInfo(this.videoUrl);
            if (!mpdUrl) {
                throw new DownloadError("无法获得可用的直播地址 这可能不是一个直播视频");
            }
            this.logger.debug(`MPD URL: ${mpdUrl}`);
            this.isLowLatencyLiveStream = isLowLatencyLiveStream;
            this.isPremiumVideo = isPremiumVideo;
            this.outputFilename = escape_filename_1.default(`${title}.mp4`);
            this.logger.info("正在获取播放列表");
            const mpdStr = (yield axios_1.default.get(mpdUrl)).data;
            const parseResult = mpd_parser_1.default(mpdStr);
            // 创建工作目录
            this.workDirectoryName = `kkr_download_${Date.now()}`;
            fs.mkdirSync(this.workDirectoryName);
            fs.mkdirSync(path.resolve(this.workDirectoryName, "./video_download"));
            fs.mkdirSync(path.resolve(this.workDirectoryName, "./audio_download"));
            const { selectedVideoTrack, selectedAudioTrack } = select_format_1.default(this.format, parseResult);
            this.videoChunkUrls = selectedVideoTrack.urls;
            this.audioChunkUrls = selectedAudioTrack.urls;
            yield download_files_1.default(this.videoChunkUrls, path.resolve(this.workDirectoryName, "./video_download"), this.maxThreads, Object.assign({ verbose: this.verbose }, (this.enableCustomHeaders ? { headers: this.rawHeaders } : {})));
            yield download_files_1.default(this.audioChunkUrls, path.resolve(this.workDirectoryName, "./audio_download"), this.maxThreads, Object.assign({ verbose: this.verbose }, (this.enableCustomHeaders ? { headers: this.rawHeaders } : {})));
            this.downloadedVideoChunkFiles = fs.readdirSync(path.resolve(this.workDirectoryName, "./video_download"));
            this.downloadedAudioChunkFiles = fs.readdirSync(path.resolve(this.workDirectoryName, "./audio_download"));
            if (!this.isFFmpegAvailable) {
                this.logger.error("FFmpeg不可用 请手动合并文件");
                this.logger.error(`临时文件目录位于 ${path.resolve(this.workDirectoryName)}`);
                process.exit();
            }
            this.logger.info(`准备混流输出文件`);
            let useDirectConcat = true;
            let concatMethodGuessing = false;
            if (this.concatMethod) {
                this.logger.info(`手动指定了合并模式${this.concatMethod}`);
                useDirectConcat = this.concatMethod === analyse_concat_method_1.ConcatMethod.DIRECT_CONCAT;
                concatMethodGuessing = false;
            }
            else {
                if (!this.isFFprobeAvailable) {
                    this.logger.warning("FFprobe不可用 无法从视频信息分析合并模式 将进行自动分析 自动分析结果可能错误 临时文件将不会被删除");
                    concatMethodGuessing = true;
                }
                else {
                    if (this.downloadedVideoChunkFiles.length === 1) {
                        // pass
                    }
                    else {
                        const result = yield analyse_concat_method_1.default(path.resolve(this.workDirectoryName, "./video_download", this.downloadedVideoChunkFiles[0]), path.resolve(this.workDirectoryName, "./video_download", this.downloadedVideoChunkFiles[1]));
                        if (result === analyse_concat_method_1.ConcatMethod.FFMPEG_CONCAT) {
                            useDirectConcat = false;
                        }
                        if (result === analyse_concat_method_1.ConcatMethod.UNKNOWN) {
                            this.logger.warning(`FFprobe分析视频内容失败 自动分析结果可能错误 临时文件将不会被删除`);
                            concatMethodGuessing = true;
                        }
                    }
                }
            }
            if (concatMethodGuessing) {
                this.keepTemporaryFiles = true;
                this.logger.info(`kkr决定猜一下合并方法`);
                // 自动猜测合并方式
                if (this.isPremiumVideo) {
                    this.logger.info(`由于本视频为首播视频 kkr觉得应该使用合并模式${analyse_concat_method_1.ConcatMethod.FFMPEG_CONCAT}`);
                    useDirectConcat = false;
                }
                else {
                    if (!this.isLowLatencyLiveStream) {
                        this.logger.info(`由于本视频为非低延迟视频 kkr觉得应该使用合并模式${analyse_concat_method_1.ConcatMethod.FFMPEG_CONCAT}`);
                        useDirectConcat = false;
                    }
                    else {
                        this.logger.info(`kkr觉得这个视频可以使用合并模式${analyse_concat_method_1.ConcatMethod.DIRECT_CONCAT}`);
                    }
                }
            }
            const videoMuxer = new video_muxer_1.VideoMuxer(this.outputFilename);
            if (useDirectConcat) {
                this.logger.info(`合并视频文件`);
                yield merge_files_1.default(this.downloadedVideoChunkFiles.map((f) => path.resolve(this.workDirectoryName, "./video_download", f)), path.resolve(this.workDirectoryName, "./video_download/video.mp4"));
                this.logger.info(`合并音频文件`);
                yield merge_files_1.default(this.downloadedAudioChunkFiles.map((f) => path.resolve(this.workDirectoryName, "./audio_download", f)), path.resolve(this.workDirectoryName, "./audio_download/audio.mp4"));
                videoMuxer.addVideoTracks(new video_muxer_1.VideoTrack({
                    path: path.resolve(this.workDirectoryName, "./video_download/video.mp4"),
                }));
                videoMuxer.addAudioTracks(new video_muxer_1.AudioTrack({
                    path: path.resolve(this.workDirectoryName, "./audio_download/audio.mp4"),
                }));
            }
            else {
                fs.writeFileSync(path.resolve(this.workDirectoryName, "video_files.txt"), this.downloadedVideoChunkFiles
                    .map((f) => `file '${path.resolve(this.workDirectoryName, "./video_download", f)}'`)
                    .join("\n"));
                fs.writeFileSync(path.resolve(this.workDirectoryName, "audio_files.txt"), this.downloadedVideoChunkFiles
                    .map((f) => `file '${path.resolve(this.workDirectoryName, "./audio_download", f)}'`)
                    .join("\n"));
                videoMuxer.addVideoSequences(new video_muxer_1.VideoSequence({
                    path: path.resolve(this.workDirectoryName, "video_files.txt"),
                }));
                videoMuxer.addAudioSequences(new video_muxer_1.AudioSequence({
                    path: path.resolve(this.workDirectoryName, "audio_files.txt"),
                }));
            }
            videoMuxer.on("success", () => __awaiter(this, void 0, void 0, function* () {
                if (!this.keepTemporaryFiles) {
                    this.logger.info(`混流完成 正删除临时文件`);
                    yield delete_directory_1.default(this.workDirectoryName);
                }
                this.logger.info(`输出文件位于${this.outputFilename}`);
                process.exit();
            }));
            videoMuxer.run();
        });
    }
}
exports.default = Downloader;
//# sourceMappingURL=downloader.js.map